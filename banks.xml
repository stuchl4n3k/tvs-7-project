<?xml version="1.0" encoding="utf-8"?><!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.1//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_1.dtd'><nta><declaration>// Place global declarations here.
// if a problem is true then the constraint has been violated
//
//
//
typedef struct {
	bool atBankA;
	bool atBankB;
} boat_t;
broadcast chan boatSail;

int[0,6] persons;

const int BOY = 1;
const int GIRL = 2;
const int DAD = 3;
const int MOM = 4;
const int THIEF = 5;
const int POLICE = 6;
const int EMPTY = 0;


const int PERSON_COUNT = 5;
//const int PERSON_COUNT = 8;
const int BOAT_CAPACITY = 2;


int bankA[PERSON_COUNT] = {THIEF,POLICE,BOY,BOY,DAD};
int bankB[PERSON_COUNT] = {EMPTY,EMPTY,EMPTY,EMPTY,EMPTY};
int boatGroup[PERSON_COUNT] = {EMPTY,EMPTY,EMPTY,EMPTY,EMPTY};

//int bankA[PERSON_COUNT] = {THIEF,POLICE,BOY,BOY,DAD,MOM,GIRL,GIRL};
//int bankB[PERSON_COUNT] = {EMPTY,EMPTY,EMPTY,EMPTY,EMPTY,MOM,GIRL,GIRL};
//int boatGroup[PERSON_COUNT] = {EMPTY,EMPTY,EMPTY,EMPTY,EMPTY,MOM,GIRL,GIRL};


void addPerson(int &amp;group[PERSON_COUNT], int personID) {
	int i;
	for (i = 0; i &lt; PERSON_COUNT; i++) {
 		if (group[i] == EMPTY) {
			group[i] = personID;
			return;
		}
	}
 	return;
}

void removePerson(int &amp;group[PERSON_COUNT], int personID) {
	int i;
 	for (i = 0; i &lt; PERSON_COUNT; i++) {
  		if (group[i] == personID) {
   			group[i] = EMPTY;
			return;
     		}
 	}
 	return;
}

int count(int group[PERSON_COUNT]) {
	int i = 0;
	int groupSize = 0;
	for (i = 0 ; i &lt; PERSON_COUNT ; i++) {
		if(group[i] != EMPTY) {
			groupSize++;	
		}		
	}
	return groupSize;
}

bool contains(int group[PERSON_COUNT], int personType) {
	int i;
	for(i = 0 ; i &lt; PERSON_COUNT ; i++) {
		if (group[i] == personType) {
			return true;
		}
	}
	
	return false;
}

bool boatProblem() {
	bool empty = count(boatGroup) &lt;= 0;
	bool overloaded = count(boatGroup) &gt; BOAT_CAPACITY;
	bool driverOk = contains(boatGroup, POLICE) || contains(boatGroup, DAD) || contains(boatGroup, MOM);

	if (empty || overloaded || !driverOk) {
		return true;
	}
	
	return false;
}

bool momProblem(int group[PERSON_COUNT]) {
	bool containsMom = contains(group, MOM);
	bool containsBoys = contains(group,BOY);
	if(containsMom &amp;&amp; containsBoys) {
		int i = 0;
		for(i=0;i&lt;PERSON_COUNT;i++) {
			if(group[i]!=MOM &amp;&amp; group[i]!=BOY) {
				return false; 
			}
		}
		return true; //nobody other than a boy and a mum found...constraint violated
	}
	return false;
}

bool kidProblem(int group[PERSON_COUNT]) {
	int i = 0;
	for(i=0;i&lt;PERSON_COUNT;i++) {
	 if(not (group[i]==BOY || group[i]==GIRL)) {
		 return false; // found a non kid in the group
		}
	}
	return true;


	

}


bool dadProblem(int group[PERSON_COUNT]) {
	bool containsDad = contains(group, DAD);
	bool containsGirl = contains(group, GIRL);

	if (containsGirl &amp;&amp; containsDad){
		// Check if dad is alone with girls (creepy).
		bool girlsDadAlone = true;
		int i=0;
		for (i &lt; 0; i&lt;PERSON_COUNT; i++) {
			if (group[i] != GIRL &amp;&amp; group[i] != DAD) {
				girlsDadAlone= false;
			}
		}
		return girlsDadAlone;
	} else {
		return false;
	}
}


bool thiefProblem(int group[PERSON_COUNT]) {
	int groupSize = count(group);

	// Thief is alone.
	if ((PERSON_COUNT-groupSize)==1) {
		return false;
	}
	
	if (contains(group,THIEF)) {
		if (not contains(group,POLICE)) {
			return true;
		}
	}
	return false;
}

bool gameWon() {
	if(count(bankB)==PERSON_COUNT) {
		return true;
	}
	return false;

}

bool groupHasProblem(int group[PERSON_COUNT]) {
	if (
		momProblem(group) ||
		dadProblem(group) ||
		thiefProblem(group) ||
		kidProblem(group)
	) {
		return true; 
	}
	return false;
	}

//checks if the model will be valid if I embark DOESNT WORK - TRASH
bool canEmbark(int personID, int fromGroup[PERSON_COUNT],int toGroup[PERSON_COUNT]) {
	bool ret = true;
	addPerson(toGroup, personID);
	removePerson(fromGroup,personID);
	if(groupHasProblem(toGroup) || groupHasProblem(fromGroup))
	{
		 ret = false;
	}
	//Dirty way but should work is it needed?
	removePerson(toGroup,personID);
	addPerson(fromGroup,personID);
	
	
	return ret;

}


bool headcountProblem() {
	int headcount = count(bankA) + count(bankB) + count(boatGroup);
	if(headcount!= PERSON_COUNT) {
		return true; // we lost/gained a person
	}	
	return false;
}


bool verifyModel() {


	
	//verify bank a
	if (groupHasProblem(bankA)) {
		return false; 
	}

	//verify bank b
	if (groupHasProblem(bankB)) {
		return false; 
	}

	//verify boat
	if (groupHasProblem(boatGroup)) {
		return false; 
	}

	return true;
}</declaration><template><name>Boat</name><parameter>boat_t &amp;boat</parameter><location id="id0" x="-136" y="-448" color="#ff0000"><name x="-240" y="-480">ERROR_STATE</name><urgent/></location><location id="id1" x="224" y="16" color="#00ff00"><name x="272" y="8">GAME_WON</name><urgent/></location><location id="id2" x="-264" y="16"><name x="-304" y="48">Unloading_A</name></location><location id="id3" x="-8" y="16"><name x="24" y="32">Loading_B</name></location><location id="id4" x="-8" y="-200"><name x="0" y="-224">Unloading_B</name></location><location id="id5" x="-264" y="-200"><name x="-360" y="-240">Loading_A</name></location><init ref="id2"/><transition><source ref="id0"/><target ref="id0"/><nail x="-64" y="-432"/><nail x="-64" y="-504"/></transition><transition><source ref="id2"/><target ref="id0"/><label kind="guard" x="-280" y="-304">headcountProblem()</label><nail x="-384" y="-232"/></transition><transition><source ref="id3"/><target ref="id0"/><label kind="guard" x="-136" y="-328">headcountProblem()</label><nail x="96" y="-224"/></transition><transition><source ref="id4"/><target ref="id0"/><label kind="guard" x="-8" y="-352">headcountProblem()</label><nail x="-88" y="-360"/></transition><transition><source ref="id5"/><target ref="id0"/><label kind="guard" x="-392" y="-360">headcountProblem()</label><nail x="-176" y="-376"/></transition><transition><source ref="id1"/><target ref="id1"/><nail x="264" y="-24"/><nail x="264" y="56"/></transition><transition><source ref="id3"/><target ref="id1"/><label kind="guard" x="32" y="-56">(gameWon())</label><nail x="128" y="-32"/></transition><transition><source ref="id3"/><target ref="id3"/><nail x="-8" y="56"/><nail x="40" y="16"/></transition><transition><source ref="id5"/><target ref="id5"/><nail x="-312" y="-200"/><nail x="-264" y="-240"/></transition><transition><source ref="id3"/><target ref="id2"/><label kind="guard" x="-240" y="-8">(not gameWon() &amp;&amp; verifyModel())</label><label kind="synchronisation" x="-168" y="-32">boatSail!</label><label kind="assignment" x="-200" y="16">boat.atBankB = false</label></transition><transition><source ref="id5"/><target ref="id4"/><label kind="guard" x="-184" y="-224">(verifyModel())</label><label kind="synchronisation" x="-176" y="-248">boatSail!</label><label kind="assignment" x="-208" y="-192">boat.atBankA = false</label></transition><transition><source ref="id2"/><target ref="id5"/><label kind="assignment" x="-264" y="-104">boat.atBankA = true</label></transition><transition><source ref="id4"/><target ref="id3"/><label kind="assignment" x="-96" y="-112">boat.atBankB = true</label></transition></template><template><name x="5" y="5">Person</name><parameter>boat_t &amp;boat, const int ID</parameter><declaration>// Place local declarations here.
        </declaration><location id="id6" x="216" y="-64"><name x="264" y="-80">Bank_B</name></location><location id="id7" x="-416" y="-64"><name x="-512" y="-80">Bank_A</name></location><location id="id8" x="72" y="-64"><name x="-8" y="-80">Board_B</name></location><location id="id9" x="-264" y="-64"><name x="-240" y="-80">Board_A</name></location><init ref="id7"/><transition><source ref="id8"/><target ref="id9"/><label kind="synchronisation" x="-128" y="-8">boatSail?</label><nail x="24" y="16"/><nail x="-224" y="16"/></transition><transition><source ref="id9"/><target ref="id8"/><label kind="synchronisation" x="-128" y="-160">boatSail?</label><nail x="-224" y="-136"/><nail x="24" y="-136"/></transition><transition><source ref="id6"/><target ref="id8"/><label kind="guard" x="104" y="16">(boat.atBankB)</label><label kind="assignment" x="80" y="-24">removePerson(bankB, ID),
addPerson(boatGroup, ID)</label><nail x="176" y="-32"/><nail x="112" y="-32"/></transition><transition><source ref="id8"/><target ref="id6"/><label kind="guard" x="104" y="-128">(boat.atBankB)</label><label kind="assignment" x="72" y="-168">removePerson(boatGroup, ID),
addPerson(bankB, ID)</label><nail x="112" y="-96"/><nail x="176" y="-96"/></transition><transition><source ref="id6"/><target ref="id6"/><nail x="256" y="-40"/><nail x="256" y="-80"/></transition><transition><source ref="id7"/><target ref="id7"/><nail x="-456" y="-40"/><nail x="-456" y="-88"/></transition><transition><source ref="id9"/><target ref="id7"/><label kind="guard" x="-400" y="-120">(boat.atBankA)</label><label kind="assignment" x="-424" y="-24">removePerson(boatGroup, ID),
addPerson(bankA, ID)</label><nail x="-304" y="-32"/><nail x="-384" y="-32"/></transition><transition><source ref="id7"/><target ref="id9"/><label kind="guard" x="-384" y="24">(boat.atBankA)</label><label kind="assignment" x="-424" y="-160">removePerson(bankA, ID),
addPerson(boatGroup, ID)</label><nail x="-384" y="-96"/><nail x="-304" y="-96"/></transition></template><system>boat_t boat = {false, false};

thiefSystem = Person(boat, THIEF);
policemanSystem = Person(boat, POLICE);
dadSystem = Person(boat, DAD);
boatSystem = Boat(boat);
boy1System = Person(boat, BOY);
boy2System = Person(boat, BOY);
//momSystem = Person(boat,MOM);
//girl1System = Person(boat,GIRL);
//girl2System = Person(boat,GIRL);

system boatSystem, thiefSystem, policemanSystem,dadSystem,boy1System,boy2System;
//momSystem,girl1System,girl2System ;</system></nta>